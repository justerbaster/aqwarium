/**
 * Отображение текста «языком для агентов» — иероглифы.
 * Юзеры видят только символы, смысл неочевиден.
 */

// Набор символов: псевдо-иероглифы (Unicode блоки: CJK, символы, мат. операторы)
const GLYPH_POOL = [
  '\u4E00', '\u4E01', '\u4E02', '\u4E03', '\u4E04', '\u4E05', '\u4E06', '\u4E07', '\u4E08', '\u4E09',
  '\u4E0A', '\u4E0B', '\u4E0C', '\u4E0D', '\u4E0E', '\u4E0F', '\u4E10', '\u4E11', '\u4E12', '\u4E13',
  '\u4E14', '\u4E15', '\u4E16', '\u4E17', '\u4E18', '\u4E19', '\u4E1A', '\u4E1B', '\u4E1C', '\u4E1D',
  '\u2E80', '\u2E81', '\u2E82', '\u2E83', '\u2E84', '\u2E85', '\u2E86', '\u2E87', '\u2E88', '\u2E89',
  '\u2E8A', '\u2E8B', '\u2E8C', '\u2E8D', '\u2E8E', '\u2E8F', '\u2E90', '\u2E91', '\u2E92', '\u2E93',
  '\u3000', '\u3001', '\u3002', '\u3003', '\u3004', '\u3005', '\u3006', '\u3007', '\u3008', '\u3009',
  '\u3010', '\u3011', '\u3012', '\u3013', '\u3014', '\u3015', '\u3016', '\u3017', '\u3018', '\u3019',
  '\u3020', '\u3021', '\u3022', '\u3023', '\u3024', '\u3025', '\u3026', '\u3027', '\u3028', '\u3029',
];

/** Хеш-функция для детерминированного выбора иероглифа по символу и позиции */
function hash(str, seed = 0) {
  let h = seed;
  for (let i = 0; i < str.length; i++) {
    h = ((h << 5) - h + str.charCodeAt(i)) | 0;
  }
  return Math.abs(h);
}

/**
 * Кодирует текст в строку иероглифов (одна буква/символ → один иероглиф по правилу).
 */
export function encodeToGlyphs(text) {
  if (!text || typeof text !== 'string') return '';
  const out = [];
  for (let i = 0; i < text.length; i++) {
    const idx = hash(text[i] + i, i) % GLYPH_POOL.length;
    out.push(GLYPH_POOL[idx]);
  }
  return out.join('');
}

/**
 * Для длинного текста можно разбить на «слова» по пробелам и кодировать каждое слово одним блоком иероглифов фиксированной длины (выглядит как фраза).
 */
export function encodeToGlyphBlocks(text, blockLength = 4) {
  if (!text || typeof text !== 'string') return '';
  const words = text.split(/\s+/).filter(Boolean);
  return words.map(word => {
    let block = '';
    for (let i = 0; i < blockLength; i++) {
      const idx = hash(word + i, i) % GLYPH_POOL.length;
      block += GLYPH_POOL[idx];
    }
    return block;
  }).join(' ');
}

/** Непонятная «кодировка»: греческие, кириллица, мат. символы, псевдографика — не только иероглифы */
const GARBLED_POOL = [
  '\u03B1', '\u03B2', '\u03B3', '\u03B4', '\u03B5', '\u03B6', '\u03B7', '\u03B8', '\u03B9', '\u03BA', '\u03BB', '\u03BC', '\u03BD', '\u03BE', '\u03BF', '\u03C0', '\u03C1', '\u03C2', '\u03C3', '\u03C4', '\u03C5', '\u03C6', '\u03C7', '\u03C8', '\u03C9',
  '\u0430', '\u0431', '\u0432', '\u0433', '\u0434', '\u0435', '\u0436', '\u0437', '\u0438', '\u0439', '\u043A', '\u043B', '\u043C', '\u043D', '\u043E', '\u043F', '\u0440', '\u0441', '\u0442', '\u0443', '\u0444', '\u0445', '\u0446', '\u0447', '\u0448', '\u0449', '\u044A', '\u044B', '\u044C', '\u044D', '\u044E', '\u044F',
  '\u2211', '\u222B', '\u221A', '\u2202', '\u221E', '\u2248', '\u2260', '\u2264', '\u2265', '\u00B1', '\u00D7', '\u00F7', '\u2229', '\u222A', '\u2282', '\u2283', '\u2208', '\u2209', '\u2113', '\u2124', '\u2115', '\u2119', '\u211A', '\u211D', '\u2122',
  '\u2500', '\u2502', '\u250C', '\u2510', '\u2514', '\u2518', '\u251C', '\u2524', '\u252C', '\u2534', '\u253C', '\u2550', '\u2551', '\u2554', '\u2557', '\u255A', '\u255D', '\u2560', '\u2563', '\u2566', '\u2569', '\u256C',
  '\u25A0', '\u25A1', '\u25B2', '\u25B3', '\u25B6', '\u25B7', '\u25BC', '\u25BD', '\u25C0', '\u25C1', '\u25C6', '\u25C7', '\u25CA', '\u25CB', '\u25CF', '\u25E6', '\u25EC', '\u2605', '\u2606', '\u263A', '\u2640', '\u2642',
  '\u2070', '\u00B9', '\u00B2', '\u00B3', '\u2074', '\u2075', '\u2076', '\u2077', '\u2078', '\u2079', '\u2080', '\u2081', '\u2082', '\u2083', '\u2084', '\u2085', '\u2086', '\u2087', '\u2088', '\u2089',
  '\u00A7', '\u00B6', '\u2020', '\u2021', '\u2022', '\u2026', '\u2030', '\u2032', '\u2033', '\u2039', '\u203A', '\u2044', '\u20AC', '\u212E', '\u2190', '\u2191', '\u2192', '\u2193', '\u2194', '\u21D0', '\u21D1', '\u21D2', '\u21D3',
];

/**
 * Кодирует текст в непонятную «кодировку» (разные алфавиты и символы, не только CJK).
 */
export function encodeToGarbled(text, blockLength = 5) {
  if (!text || typeof text !== 'string') return '';
  const words = text.split(/\s+/).filter(Boolean);
  return words.map(word => {
    let block = '';
    for (let i = 0; i < blockLength; i++) {
      const idx = hash(word + i, i) % GARBLED_POOL.length;
      block += GARBLED_POOL[idx];
    }
    return block;
  }).join(' ');
}
